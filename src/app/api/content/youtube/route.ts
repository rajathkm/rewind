import { NextRequest, NextResponse } from "next/server";
import { createClient } from "@/lib/supabase/server";
import { createAdminClient } from "@/lib/supabase/admin";
import {
  validateYouTubeUrl,
  fetchYouTubeVideoData,
} from "@/lib/youtube";

// Demo user ID for development without auth
const DEMO_USER_ID = "00000000-0000-0000-0000-000000000000";

// Demo source ID for YouTube videos (created without a subscription)
const YOUTUBE_SOURCE_ID = "00000000-0000-0000-0000-000000000001";

export async function POST(request: NextRequest) {
  try {
    const supabase = await createClient();
    const {
      data: { user },
    } = await supabase.auth.getUser();

    // Use admin client and demo user for development
    const db = user ? supabase : createAdminClient();
    const userId = user?.id || DEMO_USER_ID;

    const body = await request.json();
    const { url } = body;

    if (!url || typeof url !== "string") {
      return NextResponse.json(
        { error: "YouTube URL is required" },
        { status: 400 }
      );
    }

    // Validate the YouTube URL
    const validation = validateYouTubeUrl(url);

    if (!validation.isValid) {
      return NextResponse.json(
        { error: validation.error },
        { status: 400 }
      );
    }

    const { videoId } = validation;

    // Check if this video already exists for this user
    const { data: existingContent } = await db
      .from("content_items")
      .select("id, processing_status, title")
      .eq("youtube_video_id", videoId)
      .single();

    if (existingContent) {
      return NextResponse.json({
        success: true,
        contentId: existingContent.id,
        status: existingContent.processing_status,
        message: "Video already submitted",
        isExisting: true,
      });
    }

    // Ensure we have a YouTube source for standalone videos
    const sourceId = YOUTUBE_SOURCE_ID;
    const { data: existingSource } = await db
      .from("content_sources")
      .select("id")
      .eq("id", YOUTUBE_SOURCE_ID)
      .single();

    if (!existingSource) {
      // Create the YouTube source
      const { error: sourceError } = await db
        .from("content_sources")
        .insert({
          id: YOUTUBE_SOURCE_ID,
          source_type: "rss", // Using rss as base type since youtube isn't in enum yet
          title: "YouTube Videos",
          description: "Manually submitted YouTube videos",
          feed_url: "https://www.youtube.com",
          website_url: "https://www.youtube.com",
          is_verified: true,
        })
        .select()
        .single();

      if (sourceError && !sourceError.message.includes("duplicate")) {
        console.error("[YouTube API] Error creating source:", sourceError);
        // Continue anyway - the source might exist but RLS prevents us from seeing it
      }
    }

    // Fetch video data (metadata + transcript)
    console.log(`[YouTube API] Fetching data for video: ${videoId}`);
    const videoData = await fetchYouTubeVideoData(videoId);

    // Create the content item
    const contentItem = {
      source_id: sourceId,
      content_type: "youtube_video",
      guid: `youtube:${videoId}`,
      title: videoData.metadata.title,
      url: validation.url,
      author: videoData.metadata.channelName,
      content_text: videoData.transcript?.text || videoData.metadata.description,
      excerpt: videoData.metadata.description?.slice(0, 300) || "",
      duration_seconds: videoData.metadata.durationSeconds,
      transcript: videoData.transcript?.text,
      image_url: videoData.metadata.thumbnailUrl,
      published_at: videoData.metadata.publishedAt || new Date().toISOString(),
      processing_status: videoData.transcript ? "pending" : "failed",
      youtube_video_id: videoId,
      youtube_channel_name: videoData.metadata.channelName,
      youtube_channel_id: videoData.metadata.channelId,
      youtube_thumbnail_url: videoData.metadata.thumbnailUrl,
      transcript_source: videoData.transcript?.isAutoGenerated ? "auto" : videoData.transcript ? "manual" : null,
    };

    const { data: newContent, error: contentError } = await db
      .from("content_items")
      .insert(contentItem)
      .select()
      .single();

    if (contentError) {
      console.error("[YouTube API] Error creating content:", contentError);
      return NextResponse.json(
        { error: "Failed to create content item" },
        { status: 500 }
      );
    }

    // Create user content state for tracking
    await db.from("user_content_state").insert({
      user_id: userId,
      content_id: newContent.id,
      is_read: false,
      is_saved: false,
    });

    // Return success response
    return NextResponse.json({
      success: true,
      contentId: newContent.id,
      status: newContent.processing_status,
      hasTranscript: !!videoData.transcript,
      transcriptSource: videoData.transcript?.isAutoGenerated ? "auto" : "manual",
      message: videoData.error || "Video submitted for summarization",
      video: {
        id: videoId,
        title: videoData.metadata.title,
        channelName: videoData.metadata.channelName,
        thumbnailUrl: videoData.metadata.thumbnailUrl,
        durationSeconds: videoData.metadata.durationSeconds,
      },
    });
  } catch (error) {
    console.error("[YouTube API] Error:", error);
    return NextResponse.json(
      { error: "Internal server error" },
      { status: 500 }
    );
  }
}

/**
 * GET endpoint to check processing status
 */
export async function GET(request: NextRequest) {
  try {
    const supabase = await createClient();
    const {
      data: { user },
    } = await supabase.auth.getUser();

    const db = user ? supabase : createAdminClient();

    const searchParams = request.nextUrl.searchParams;
    const contentId = searchParams.get("contentId");
    const videoId = searchParams.get("videoId");

    if (!contentId && !videoId) {
      return NextResponse.json(
        { error: "contentId or videoId is required" },
        { status: 400 }
      );
    }

    let query = db
      .from("content_items")
      .select(
        `
        id,
        title,
        processing_status,
        youtube_video_id,
        youtube_channel_name,
        youtube_thumbnail_url,
        duration_seconds,
        transcript,
        summaries (
          id,
          headline,
          tldr
        )
      `
      );

    if (contentId) {
      query = query.eq("id", contentId);
    } else if (videoId) {
      query = query.eq("youtube_video_id", videoId);
    }

    const { data, error } = await query.single();

    if (error) {
      return NextResponse.json(
        { error: "Content not found" },
        { status: 404 }
      );
    }

    return NextResponse.json({
      contentId: data.id,
      videoId: data.youtube_video_id,
      title: data.title,
      channelName: data.youtube_channel_name,
      thumbnailUrl: data.youtube_thumbnail_url,
      durationSeconds: data.duration_seconds,
      status: data.processing_status,
      hasTranscript: !!data.transcript,
      hasSummary: data.summaries && data.summaries.length > 0,
      summary: data.summaries?.[0] || null,
    });
  } catch (error) {
    console.error("[YouTube API] Error:", error);
    return NextResponse.json(
      { error: "Internal server error" },
      { status: 500 }
    );
  }
}
