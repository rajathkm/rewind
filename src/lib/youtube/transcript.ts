/**
 * YouTube transcript extraction service
 *
 * Extracts captions/transcripts from YouTube videos using publicly available
 * caption data. Falls back to video metadata if no captions are available.
 */

import { getYouTubeThumbnailUrl } from "./url-parser";

export interface YouTubeVideoMetadata {
  videoId: string;
  title: string;
  channelName: string;
  channelId?: string;
  description: string;
  publishedAt?: string;
  durationSeconds?: number;
  thumbnailUrl: string;
  viewCount?: number;
  likeCount?: number;
}

export interface YouTubeTranscript {
  text: string;
  segments: TranscriptSegment[];
  language: string;
  isAutoGenerated: boolean;
}

export interface TranscriptSegment {
  text: string;
  startTime: number;
  duration: number;
}

export interface YouTubeVideoData {
  metadata: YouTubeVideoMetadata;
  transcript: YouTubeTranscript | null;
  error?: string;
}

/**
 * Fetch video metadata from YouTube's oembed endpoint
 */
async function fetchVideoMetadata(
  videoId: string
): Promise<YouTubeVideoMetadata | null> {
  try {
    const url = `https://www.youtube.com/oembed?url=https://www.youtube.com/watch?v=${videoId}&format=json`;
    const response = await fetch(url);

    if (!response.ok) {
      console.error(`[YouTube] Failed to fetch oembed for ${videoId}: ${response.status}`);
      return null;
    }

    const data = await response.json();

    return {
      videoId,
      title: data.title || "Untitled Video",
      channelName: data.author_name || "Unknown Channel",
      description: "",
      thumbnailUrl:
        data.thumbnail_url || getYouTubeThumbnailUrl(videoId, "high"),
    };
  } catch (error) {
    console.error("[YouTube] Error fetching oembed:", error);
    return null;
  }
}

/**
 * Fetch video page and extract additional metadata
 */
async function fetchVideoPageMetadata(
  videoId: string
): Promise<Partial<YouTubeVideoMetadata>> {
  try {
    const url = `https://www.youtube.com/watch?v=${videoId}`;
    const response = await fetch(url, {
      headers: {
        "User-Agent":
          "Mozilla/5.0 (compatible; Rewind/1.0; +https://rewind.app)",
        "Accept-Language": "en-US,en;q=0.9",
      },
    });

    if (!response.ok) {
      console.error(`[YouTube] Failed to fetch video page: ${response.status}`);
      return {};
    }

    const html = await response.text();

    // Extract duration from meta tag
    const durationMatch = html.match(
      /<meta itemprop="duration" content="PT(\d+)M(\d+)S"/
    );
    let durationSeconds: number | undefined;
    if (durationMatch) {
      durationSeconds =
        parseInt(durationMatch[1]) * 60 + parseInt(durationMatch[2]);
    }

    // Extract description
    const descMatch = html.match(
      /<meta name="description" content="([^"]*)">/
    );
    const description = descMatch
      ? descMatch[1].replace(/&#39;/g, "'").replace(/&quot;/g, '"')
      : "";

    // Extract channel ID
    const channelIdMatch = html.match(/"channelId":"([^"]+)"/);
    const channelId = channelIdMatch ? channelIdMatch[1] : undefined;

    // Extract publish date
    const publishMatch = html.match(
      /<meta itemprop="datePublished" content="([^"]+)"/
    );
    const publishedAt = publishMatch ? publishMatch[1] : undefined;

    return {
      durationSeconds,
      description,
      channelId,
      publishedAt,
    };
  } catch (error) {
    console.error("[YouTube] Error fetching video page:", error);
    return {};
  }
}

/**
 * Attempt to extract captions/transcript from YouTube
 *
 * This uses the timedtext API which provides auto-generated captions
 */
async function fetchTranscript(
  videoId: string
): Promise<YouTubeTranscript | null> {
  try {
    // First, we need to get the caption tracks from the video page
    const videoUrl = `https://www.youtube.com/watch?v=${videoId}`;
    const response = await fetch(videoUrl, {
      headers: {
        "User-Agent":
          "Mozilla/5.0 (compatible; Rewind/1.0; +https://rewind.app)",
        "Accept-Language": "en-US,en;q=0.9",
      },
    });

    if (!response.ok) {
      console.error(`[YouTube] Failed to fetch video page for transcript: ${response.status}`);
      return null;
    }

    const html = await response.text();

    // Look for caption track URLs in the player response
    const captionRegex = /"captionTracks":\s*(\[.*?\])/;
    const match = html.match(captionRegex);

    if (!match) {
      console.log(`[YouTube] No caption tracks found for video ${videoId}`);
      return null;
    }

    let captionTracks;
    try {
      // The JSON might have escaped characters
      const jsonStr = match[1].replace(/\\"/g, '"').replace(/\\\\/g, "\\");
      captionTracks = JSON.parse(jsonStr);
    } catch {
      // Try to extract baseUrl directly using a simpler pattern
      const baseUrlMatch = html.match(
        /"baseUrl":"(https:\/\/www\.youtube\.com\/api\/timedtext[^"]+)"/
      );
      if (!baseUrlMatch) {
        console.log(`[YouTube] Could not parse caption tracks for ${videoId}`);
        return null;
      }

      // Decode the URL
      const captionUrl = baseUrlMatch[1]
        .replace(/\\u0026/g, "&")
        .replace(/\\\//g, "/");

      return await fetchTranscriptFromUrl(captionUrl, false);
    }

    if (!Array.isArray(captionTracks) || captionTracks.length === 0) {
      console.log(`[YouTube] No caption tracks available for ${videoId}`);
      return null;
    }

    // Prefer English captions, then auto-generated, then any available
    const selectedTrack =
      captionTracks.find(
        (t: { languageCode: string; kind?: string }) =>
          t.languageCode === "en" && t.kind !== "asr"
      ) ||
      captionTracks.find(
        (t: { languageCode: string }) => t.languageCode === "en"
      ) ||
      captionTracks.find((t: { kind?: string }) => t.kind !== "asr") ||
      captionTracks[0];

    if (!selectedTrack || !selectedTrack.baseUrl) {
      console.log(`[YouTube] No usable caption track for ${videoId}`);
      return null;
    }

    const isAutoGenerated = selectedTrack.kind === "asr";
    const language = selectedTrack.languageCode || "en";

    // Decode the URL
    const captionUrl = selectedTrack.baseUrl
      .replace(/\\u0026/g, "&")
      .replace(/\\\//g, "/");

    return await fetchTranscriptFromUrl(captionUrl, isAutoGenerated, language);
  } catch (error) {
    console.error("[YouTube] Error fetching transcript:", error);
    return null;
  }
}

async function fetchTranscriptFromUrl(
  captionUrl: string,
  isAutoGenerated: boolean,
  language: string = "en"
): Promise<YouTubeTranscript | null> {
  try {
    // Add format=json3 for structured output
    const url = captionUrl.includes("fmt=")
      ? captionUrl
      : `${captionUrl}&fmt=json3`;

    const response = await fetch(url);
    if (!response.ok) {
      console.error(`[YouTube] Failed to fetch captions: ${response.status}`);
      return null;
    }

    const contentType = response.headers.get("content-type");

    // Try JSON format first
    if (contentType?.includes("application/json")) {
      const data = await response.json();
      if (data.events) {
        const segments: TranscriptSegment[] = [];
        let fullText = "";

        for (const event of data.events) {
          if (event.segs) {
            const text = event.segs.map((s: { utf8?: string }) => s.utf8 || "").join("");
            if (text.trim()) {
              segments.push({
                text: text.trim(),
                startTime: (event.tStartMs || 0) / 1000,
                duration: (event.dDurationMs || 0) / 1000,
              });
              fullText += text + " ";
            }
          }
        }

        return {
          text: fullText.trim(),
          segments,
          language,
          isAutoGenerated,
        };
      }
    }

    // Try XML format as fallback
    const text = await response.text();
    const segments: TranscriptSegment[] = [];
    let fullText = "";

    // Parse XML transcript
    const textRegex = /<text start="([\d.]+)" dur="([\d.]+)"[^>]*>([^<]*)<\/text>/g;
    let textMatch;

    while ((textMatch = textRegex.exec(text)) !== null) {
      const segmentText = decodeHTMLEntities(textMatch[3]);
      if (segmentText.trim()) {
        segments.push({
          text: segmentText.trim(),
          startTime: parseFloat(textMatch[1]),
          duration: parseFloat(textMatch[2]),
        });
        fullText += segmentText + " ";
      }
    }

    if (segments.length === 0) {
      return null;
    }

    return {
      text: fullText.trim(),
      segments,
      language,
      isAutoGenerated,
    };
  } catch (error) {
    console.error("[YouTube] Error parsing transcript:", error);
    return null;
  }
}

function decodeHTMLEntities(text: string): string {
  return text
    .replace(/&amp;/g, "&")
    .replace(/&lt;/g, "<")
    .replace(/&gt;/g, ">")
    .replace(/&quot;/g, '"')
    .replace(/&#39;/g, "'")
    .replace(/&apos;/g, "'")
    .replace(/\\n/g, " ")
    .replace(/\n/g, " ");
}

/**
 * Main function to fetch all YouTube video data
 */
export async function fetchYouTubeVideoData(
  videoId: string
): Promise<YouTubeVideoData> {
  console.log(`[YouTube] Fetching data for video: ${videoId}`);

  // Fetch metadata and transcript in parallel
  const [oembedData, pageMetadata, transcript] = await Promise.all([
    fetchVideoMetadata(videoId),
    fetchVideoPageMetadata(videoId),
    fetchTranscript(videoId),
  ]);

  if (!oembedData) {
    return {
      metadata: {
        videoId,
        title: "Video Not Found",
        channelName: "Unknown",
        description: "",
        thumbnailUrl: getYouTubeThumbnailUrl(videoId, "high"),
      },
      transcript: null,
      error: "Could not fetch video metadata. The video may be private or unavailable.",
    };
  }

  // Merge metadata from both sources
  const metadata: YouTubeVideoMetadata = {
    ...oembedData,
    ...pageMetadata,
    // Preserve oembed values if page metadata is empty
    title: oembedData.title,
    channelName: oembedData.channelName,
    thumbnailUrl: oembedData.thumbnailUrl,
    description: pageMetadata.description || oembedData.description,
  };

  return {
    metadata,
    transcript,
    error: transcript
      ? undefined
      : "No captions available for this video. Summary will be based on title and description only.",
  };
}
