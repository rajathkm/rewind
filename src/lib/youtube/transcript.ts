/**
 * YouTube transcript extraction service
 *
 * Extracts captions/transcripts from YouTube videos using the youtube-transcript
 * library for reliability. Falls back to HTML scraping if the library fails.
 *
 * Features:
 * - Primary: youtube-transcript library (most reliable)
 * - Fallback: HTML scraping for caption URLs
 * - Rate limiting to prevent being blocked
 * - Retry logic with exponential backoff
 * - Detailed error classification
 */

import { YoutubeTranscript } from "youtube-transcript";
import { getYouTubeThumbnailUrl } from "./url-parser";
import {
  fetchWithRetry,
  fetchHtmlWithRetry,
} from "./fetch-with-retry";
import {
  YouTubeError,
  YouTubeErrorCode,
  createYouTubeError,
  detectErrorFromHtml,
  wrapError,
} from "./errors";

export interface YouTubeVideoMetadata {
  videoId: string;
  title: string;
  channelName: string;
  channelId?: string;
  description: string;
  publishedAt?: string;
  durationSeconds?: number;
  thumbnailUrl: string;
  viewCount?: number;
  likeCount?: number;
}

export interface YouTubeTranscript {
  text: string;
  segments: TranscriptSegment[];
  language: string;
  isAutoGenerated: boolean;
}

export interface TranscriptSegment {
  text: string;
  startTime: number;
  duration: number;
}

export interface YouTubeVideoData {
  metadata: YouTubeVideoMetadata;
  transcript: YouTubeTranscript | null;
  error?: YouTubeError;
  errorMessage?: string;
}

// Common request headers for YouTube
const YOUTUBE_HEADERS = {
  "User-Agent": "Mozilla/5.0 (compatible; Rewind/1.0; +https://rewind.app)",
  "Accept-Language": "en-US,en;q=0.9",
};

/**
 * Fetch video metadata from YouTube's oembed endpoint
 */
async function fetchVideoMetadata(
  videoId: string
): Promise<YouTubeVideoMetadata | null> {
  const url = `https://www.youtube.com/oembed?url=https://www.youtube.com/watch?v=${videoId}&format=json`;

  try {
    const response = await fetchWithRetry(
      url,
      { headers: YOUTUBE_HEADERS },
      { videoId, maxRetries: 2 }
    );

    const data = await response.json();

    return {
      videoId,
      title: data.title || "Untitled Video",
      channelName: data.author_name || "Unknown Channel",
      description: "",
      thumbnailUrl:
        data.thumbnail_url || getYouTubeThumbnailUrl(videoId, "high"),
    };
  } catch (error) {
    if (error instanceof YouTubeError) {
      console.error(
        `[YouTube] Failed to fetch oembed for ${videoId}: ${error.code} - ${error.message}`
      );
    } else {
      console.error("[YouTube] Error fetching oembed:", error);
    }
    return null;
  }
}

/**
 * Fetch video page and extract additional metadata
 */
async function fetchVideoPageMetadata(
  videoId: string
): Promise<{ metadata: Partial<YouTubeVideoMetadata>; html: string; error?: YouTubeError }> {
  const url = `https://www.youtube.com/watch?v=${videoId}`;

  try {
    const { html } = await fetchHtmlWithRetry(
      url,
      { headers: YOUTUBE_HEADERS },
      { videoId, maxRetries: 2, checkHtmlForErrors: true }
    );

    // Check for errors in the HTML
    const htmlError = detectErrorFromHtml(html, videoId);
    if (htmlError) {
      return { metadata: {}, html, error: htmlError };
    }

    // Extract duration from meta tag
    const durationMatch = html.match(
      /<meta itemprop="duration" content="PT(\d+)M(\d+)S"/
    );
    let durationSeconds: number | undefined;
    if (durationMatch) {
      durationSeconds =
        parseInt(durationMatch[1]) * 60 + parseInt(durationMatch[2]);
    }

    // Try alternative duration format (hours included)
    if (!durationSeconds) {
      const altDurationMatch = html.match(
        /<meta itemprop="duration" content="PT(?:(\d+)H)?(?:(\d+)M)?(\d+)S"/
      );
      if (altDurationMatch) {
        const hours = parseInt(altDurationMatch[1] || "0");
        const minutes = parseInt(altDurationMatch[2] || "0");
        const seconds = parseInt(altDurationMatch[3] || "0");
        durationSeconds = hours * 3600 + minutes * 60 + seconds;
      }
    }

    // Extract description
    const descMatch = html.match(
      /<meta name="description" content="([^"]*)">/
    );
    const description = descMatch
      ? descMatch[1].replace(/&#39;/g, "'").replace(/&quot;/g, '"')
      : "";

    // Extract channel ID
    const channelIdMatch = html.match(/"channelId":"([^"]+)"/);
    const channelId = channelIdMatch ? channelIdMatch[1] : undefined;

    // Extract publish date
    const publishMatch = html.match(
      /<meta itemprop="datePublished" content="([^"]+)"/
    );
    const publishedAt = publishMatch ? publishMatch[1] : undefined;

    return {
      metadata: {
        durationSeconds,
        description,
        channelId,
        publishedAt,
      },
      html,
    };
  } catch (error) {
    if (error instanceof YouTubeError) {
      console.error(
        `[YouTube] Failed to fetch video page for ${videoId}: ${error.code}`
      );
      return { metadata: {}, html: "", error };
    }
    console.error("[YouTube] Error fetching video page:", error);
    return { metadata: {}, html: "", error: wrapError(error, videoId) };
  }
}

/**
 * Attempt to extract captions/transcript from YouTube
 *
 * Primary method: youtube-transcript library (most reliable)
 * Fallback: HTML scraping for caption URLs
 */
async function fetchTranscript(
  videoId: string,
  html?: string
): Promise<{ transcript: YouTubeTranscript | null; error?: YouTubeError }> {
  // Try the youtube-transcript library first (most reliable method)
  try {
    console.log(`[YouTube] Attempting to fetch transcript via library for ${videoId}`);
    const transcriptItems = await YoutubeTranscript.fetchTranscript(videoId, {
      lang: "en",
    });

    if (transcriptItems && transcriptItems.length > 0) {
      const segments: TranscriptSegment[] = transcriptItems.map((item) => ({
        text: item.text.trim(),
        startTime: item.offset / 1000, // Convert ms to seconds
        duration: item.duration / 1000,
      }));

      const fullText = segments.map((s) => s.text).join(" ");

      console.log(`[YouTube] Successfully fetched transcript via library: ${segments.length} segments, ${fullText.length} chars`);

      return {
        transcript: {
          text: fullText,
          segments,
          language: "en",
          isAutoGenerated: true, // Library doesn't distinguish, assume auto
        },
      };
    }
  } catch (libraryError) {
    console.log(`[YouTube] Library method failed for ${videoId}, trying fallback:`,
      libraryError instanceof Error ? libraryError.message : libraryError
    );
    // Continue to fallback method
  }

  // Fallback: HTML scraping method
  try {
    console.log(`[YouTube] Using HTML scraping fallback for ${videoId}`);

    // If we don't have HTML, fetch it
    let videoHtml = html;
    if (!videoHtml) {
      const result = await fetchHtmlWithRetry(
        `https://www.youtube.com/watch?v=${videoId}`,
        { headers: YOUTUBE_HEADERS },
        { videoId, maxRetries: 2, checkHtmlForErrors: true }
      );
      videoHtml = result.html;

      // Check for errors in the HTML
      const htmlError = detectErrorFromHtml(videoHtml, videoId);
      if (htmlError) {
        return { transcript: null, error: htmlError };
      }
    }

    // Look for caption track URLs in the player response
    const captionRegex = /"captionTracks":\s*(\[.*?\])/;
    const match = videoHtml.match(captionRegex);

    if (!match) {
      // Check if captions are explicitly disabled
      if (videoHtml.includes('"captionsDisabled":true')) {
        return {
          transcript: null,
          error: createYouTubeError(YouTubeErrorCode.CAPTIONS_DISABLED, { videoId }),
        };
      }

      console.log(`[YouTube] No caption tracks found for video ${videoId}`);
      return {
        transcript: null,
        error: createYouTubeError(YouTubeErrorCode.NO_CAPTIONS_AVAILABLE, { videoId }),
      };
    }

    let captionTracks;
    try {
      // The JSON might have escaped characters
      const jsonStr = match[1].replace(/\\"/g, '"').replace(/\\\\/g, "\\");
      captionTracks = JSON.parse(jsonStr);
    } catch {
      // Try to extract baseUrl directly using a simpler pattern
      const baseUrlMatch = videoHtml.match(
        /"baseUrl":"(https:\/\/www\.youtube\.com\/api\/timedtext[^"]+)"/
      );
      if (!baseUrlMatch) {
        console.log(`[YouTube] Could not parse caption tracks for ${videoId}`);
        return {
          transcript: null,
          error: createYouTubeError(YouTubeErrorCode.PARSE_ERROR, {
            message: "Could not parse caption track data",
            videoId,
          }),
        };
      }

      // Decode the URL
      const captionUrl = baseUrlMatch[1]
        .replace(/\\u0026/g, "&")
        .replace(/\\\//g, "/");

      return await fetchTranscriptFromUrl(captionUrl, false, "en", videoId);
    }

    if (!Array.isArray(captionTracks) || captionTracks.length === 0) {
      console.log(`[YouTube] No caption tracks available for ${videoId}`);
      return {
        transcript: null,
        error: createYouTubeError(YouTubeErrorCode.NO_CAPTIONS_AVAILABLE, { videoId }),
      };
    }

    // Prefer English captions, then auto-generated, then any available
    const selectedTrack =
      captionTracks.find(
        (t: { languageCode: string; kind?: string }) =>
          t.languageCode === "en" && t.kind !== "asr"
      ) ||
      captionTracks.find(
        (t: { languageCode: string }) => t.languageCode === "en"
      ) ||
      captionTracks.find((t: { kind?: string }) => t.kind !== "asr") ||
      captionTracks[0];

    if (!selectedTrack || !selectedTrack.baseUrl) {
      console.log(`[YouTube] No usable caption track for ${videoId}`);
      return {
        transcript: null,
        error: createYouTubeError(YouTubeErrorCode.NO_CAPTIONS_AVAILABLE, { videoId }),
      };
    }

    const isAutoGenerated = selectedTrack.kind === "asr";
    const language = selectedTrack.languageCode || "en";

    // Decode the URL
    const captionUrl = selectedTrack.baseUrl
      .replace(/\\u0026/g, "&")
      .replace(/\\\//g, "/");

    return await fetchTranscriptFromUrl(captionUrl, isAutoGenerated, language, videoId);
  } catch (error) {
    if (error instanceof YouTubeError) {
      console.error(`[YouTube] Error fetching transcript: ${error.code}`);
      return { transcript: null, error };
    }
    console.error("[YouTube] Error fetching transcript:", error);
    return { transcript: null, error: wrapError(error, videoId) };
  }
}

async function fetchTranscriptFromUrl(
  captionUrl: string,
  isAutoGenerated: boolean,
  language: string = "en",
  videoId?: string
): Promise<{ transcript: YouTubeTranscript | null; error?: YouTubeError }> {
  try {
    // Add format=json3 for structured output
    const url = captionUrl.includes("fmt=")
      ? captionUrl
      : `${captionUrl}&fmt=json3`;

    const response = await fetchWithRetry(
      url,
      { headers: YOUTUBE_HEADERS },
      { videoId, maxRetries: 2 }
    );

    const contentType = response.headers.get("content-type");

    // Try JSON format first
    if (contentType?.includes("application/json")) {
      const data = await response.json();
      if (data.events) {
        const segments: TranscriptSegment[] = [];
        let fullText = "";

        for (const event of data.events) {
          if (event.segs) {
            const text = event.segs
              .map((s: { utf8?: string }) => s.utf8 || "")
              .join("");
            if (text.trim()) {
              segments.push({
                text: text.trim(),
                startTime: (event.tStartMs || 0) / 1000,
                duration: (event.dDurationMs || 0) / 1000,
              });
              fullText += text + " ";
            }
          }
        }

        return {
          transcript: {
            text: fullText.trim(),
            segments,
            language,
            isAutoGenerated,
          },
        };
      }
    }

    // Try XML format as fallback
    const text = await response.clone().text();
    const segments: TranscriptSegment[] = [];
    let fullText = "";

    // Parse XML transcript
    const textRegex =
      /<text start="([\d.]+)" dur="([\d.]+)"[^>]*>([^<]*)<\/text>/g;
    let textMatch;

    while ((textMatch = textRegex.exec(text)) !== null) {
      const segmentText = decodeHTMLEntities(textMatch[3]);
      if (segmentText.trim()) {
        segments.push({
          text: segmentText.trim(),
          startTime: parseFloat(textMatch[1]),
          duration: parseFloat(textMatch[2]),
        });
        fullText += segmentText + " ";
      }
    }

    if (segments.length === 0) {
      return {
        transcript: null,
        error: createYouTubeError(YouTubeErrorCode.CAPTION_FETCH_FAILED, {
          message: "No caption segments found in response",
          videoId,
        }),
      };
    }

    return {
      transcript: {
        text: fullText.trim(),
        segments,
        language,
        isAutoGenerated,
      },
    };
  } catch (error) {
    if (error instanceof YouTubeError) {
      console.error(`[YouTube] Error parsing transcript: ${error.code}`);
      return { transcript: null, error };
    }
    console.error("[YouTube] Error parsing transcript:", error);
    return {
      transcript: null,
      error: createYouTubeError(YouTubeErrorCode.CAPTION_FETCH_FAILED, {
        message: error instanceof Error ? error.message : "Failed to fetch captions",
        videoId,
      }),
    };
  }
}

function decodeHTMLEntities(text: string): string {
  return text
    .replace(/&amp;/g, "&")
    .replace(/&lt;/g, "<")
    .replace(/&gt;/g, ">")
    .replace(/&quot;/g, '"')
    .replace(/&#39;/g, "'")
    .replace(/&apos;/g, "'")
    .replace(/\\n/g, " ")
    .replace(/\n/g, " ");
}

/**
 * Main function to fetch all YouTube video data
 */
export async function fetchYouTubeVideoData(
  videoId: string
): Promise<YouTubeVideoData> {
  console.log(`[YouTube] Fetching data for video: ${videoId}`);

  // Fetch oembed metadata first (lightweight check if video exists)
  const oembedData = await fetchVideoMetadata(videoId);

  if (!oembedData) {
    const error = createYouTubeError(YouTubeErrorCode.VIDEO_NOT_FOUND, {
      message: "Could not fetch video metadata",
      videoId,
    });
    return {
      metadata: {
        videoId,
        title: "Video Not Found",
        channelName: "Unknown",
        description: "",
        thumbnailUrl: getYouTubeThumbnailUrl(videoId, "high"),
      },
      transcript: null,
      error,
      errorMessage: error.userMessage,
    };
  }

  // Fetch page metadata (includes the HTML we'll use for transcript)
  const { metadata: pageMetadata, html, error: pageError } =
    await fetchVideoPageMetadata(videoId);

  if (pageError && !pageError.isRetryable) {
    return {
      metadata: {
        ...oembedData,
        ...pageMetadata,
        title: oembedData.title,
        channelName: oembedData.channelName,
        thumbnailUrl: oembedData.thumbnailUrl,
        description: pageMetadata.description || oembedData.description,
      },
      transcript: null,
      error: pageError,
      errorMessage: pageError.userMessage,
    };
  }

  // Fetch transcript using the HTML we already have
  const { transcript, error: transcriptError } = await fetchTranscript(videoId, html);

  // Merge metadata from both sources
  const metadata: YouTubeVideoMetadata = {
    ...oembedData,
    ...pageMetadata,
    // Preserve oembed values if page metadata is empty
    title: oembedData.title,
    channelName: oembedData.channelName,
    thumbnailUrl: oembedData.thumbnailUrl,
    description: pageMetadata.description || oembedData.description,
  };

  // Return with transcript or error
  if (transcript) {
    return {
      metadata,
      transcript,
    };
  }

  return {
    metadata,
    transcript: null,
    error: transcriptError,
    errorMessage: transcriptError?.userMessage ||
      "No captions available for this video. Summary will be based on title and description only.",
  };
}

// Re-export error types for consumers
export { YouTubeError, YouTubeErrorCode } from "./errors";
